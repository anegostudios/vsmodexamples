using System;
using Vintagestory.API.Common;
using Vintagestory.API.Datastructures;
using Vintagestory.API.Server;
using Vintagestory.ServerMods;
using System.Threading.Tasks;
using SkiaSharp;

public class AlpineStrata: ModStdWorldGen
{
    ICoreServerAPI api;
    int maxThreads;
    internal SKBitmap height_map;
    internal float data_width_per_pixel;        
    internal int max_height_custom;
    internal int min_height_custom; 
    internal UtilTool uTool;
    internal MapLayerCustomPerlin[] strataNoises;
    internal RockStrataConfig strata;
    internal int[] rockIds;
    public AlpineStrata(){}
    public AlpineStrata(ICoreServerAPI api, SKBitmap height_map, float data_width_per_pixel, int min_height_custom, UtilTool uTool)
    {
        /**
                This class will replace a layer of 10 blocks of another rock under the surface for a better gameplay experience.

                The block choice is made based on a perlin noise map associated to each rock type:
                    When the noise is greater than a threshold, the associated rock will replace the in place granite.

        */
        LoadGlobalConfig(api);
        
        this.api = api;
        this.height_map = height_map;

        maxThreads = Math.Min(Environment.ProcessorCount, api.Server.Config.HostedMode ? 4 : 10);

        max_height_custom = api.WorldManager.MapSizeY;
        this.data_width_per_pixel = data_width_per_pixel;
        this.min_height_custom = min_height_custom;

        this.uTool = uTool;
        
        IAsset asset = api.Assets.Get("worldgen/rockstrata.json");
        strata = asset.ToObject<RockStrataConfig>();

        LoadGlobalConfig(api);

        chunksize = api.WorldManager.ChunkSize;

        //  Storing the block id of different rock types.
        rockIds = new int[14];
        rockIds[0] = api.WorldManager.GetBlockId(new AssetLocation("rock-granite"));
        rockIds[1] = api.WorldManager.GetBlockId(new AssetLocation("rock-basalt"));
        rockIds[2] = api.WorldManager.GetBlockId(new AssetLocation("rock-andesite"));
        rockIds[3] = api.WorldManager.GetBlockId(new AssetLocation("rock-peridotite"));
        rockIds[4] = api.WorldManager.GetBlockId(new AssetLocation("rock-chalk"));
        rockIds[5] = api.WorldManager.GetBlockId(new AssetLocation("rock-claystone"));
        rockIds[6] = api.WorldManager.GetBlockId(new AssetLocation("rock-sandstone"));
        rockIds[7] = api.WorldManager.GetBlockId(new AssetLocation("rock-shale"));
        rockIds[8] = api.WorldManager.GetBlockId(new AssetLocation("rock-limestone"));
        rockIds[9] = api.WorldManager.GetBlockId(new AssetLocation("rock-conglomerate"));
        rockIds[10] = api.WorldManager.GetBlockId(new AssetLocation("rock-chert"));
        rockIds[11] = api.WorldManager.GetBlockId(new AssetLocation("rock-phyllite"));
        rockIds[12] = api.WorldManager.GetBlockId(new AssetLocation("rock-slate"));
        rockIds[13] = api.WorldManager.GetBlockId(new AssetLocation("rock-bauxite"));

        //  Instanciating the perlin noise maps that will be used for the strata choice
        strataNoises = new MapLayerCustomPerlin[strata.Variants.Length];
        for (int i = 0; i < strata.Variants.Length; i++)
        {
            strataNoises[i] = new MapLayerCustomPerlin(api.World.Seed + 23423 + 500*i, new double[] { 14, 0, 0, 0 }, new double[] { 1 / 100.0 / 5, 1 / 50.0 / 5, 1 / 25.0 / 5, 1 / 12.5 / 5 }, new double[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13});
        }
    }
    public override double ExecuteOrder()
    {
        return 0.13;
    }
    public void OnChunkColumnGen(IChunkColumnGenerateRequest request)
    {   
        generate(request.Chunks, request.ChunkX, request.ChunkZ, request.RequiresChunkBorderSmoothing);
    }
    private void generate(IServerChunk[] chunks, int chunkX, int chunkZ, bool requiresChunkBorderSmoothing)
    {
        //  The IntDataMap2D are 1D int containers that will store the noise map generated by the MapLayerCustomPerlin.
        //  It contains one value per X - Z coordinate.

        IntDataMap2D[] intmaps = new IntDataMap2D[strata.Variants.Length];
        
        for (int i = 0; i < strata.Variants.Length; i++)
        {
            intmaps[i] = new IntDataMap2D();
            intmaps[i].Data = strataNoises[i].GenLayer(
                chunkX*chunksize ,
                chunkZ*chunksize ,
                chunksize,
                chunksize
            );
        }

        /*
            In this loop, we read the maximal height of each X - Z column from the chunks data.
        */
        int[] maxHeights = new int[chunksize*chunksize];
        Parallel.For(0, chunksize*chunksize, new ParallelOptions() { MaxDegreeOfParallelism = maxThreads }, chunkIndex2d => {
            int lX = chunkIndex2d % chunksize;
            int lZ = chunkIndex2d / chunksize;

            int mapIndex = uTool.ChunkIndex2d(lX, lZ, chunksize);
            for(int lY = max_height_custom-1; lY > 1 ; lY--){
                int chunkIndex = uTool.ChunkIndex3d(lX, lY%chunksize, lZ, chunksize);

                if(chunks[lY/chunksize].Data[chunkIndex] == rockIds[0]){ // 0 means the block is empty
                    maxHeights[chunkIndex2d] = lY - 1;
                    break;
                }
            }
        });

        //  Setting the value of the rock in the chunks data.
        for (int lZ = 0; lZ < chunksize; lZ++)
        {
            for (int lX = 0; lX < chunksize; lX++)
            {
                int mapIndex = uTool.ChunkIndex2d(lX, lZ, chunksize);
                int maxHeight=maxHeights[mapIndex];

                for (int i = 1; i < strata.Variants.Length; i++)
                {
                    if(intmaps[i].Data[mapIndex]  > 8){
                        for (int j = 1; j < 10; j++)
                        {
                            if(maxHeight-j-5 > 0)
                            {
                                uTool.setBlockId(lX, maxHeight-j-5, lZ, chunksize, chunks, rockIds[Math.Min(13, i)]);
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
}